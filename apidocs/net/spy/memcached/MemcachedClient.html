<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_15) on Wed Sep 23 15:55:23 PDT 2009 -->
<TITLE>
MemcachedClient (Java memcached client)
</TITLE>

<META NAME="date" CONTENT="2009-09-23">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="MemcachedClient (Java memcached client)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/spy/memcached/KeyUtil.html" title="class in net.spy.memcached"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/spy/memcached/MemcachedClient.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MemcachedClient.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_java.lang.Thread">NESTED</A>&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.lang.Thread">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.spy.memcached</FONT>
<BR>
Class MemcachedClient</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.lang.Thread
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../net/spy/memcached/compat/SpyThread.html" title="class in net.spy.memcached.compat">net.spy.memcached.compat.SpyThread</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>net.spy.memcached.MemcachedClient</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Runnable, <A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public final class <B>MemcachedClient</B><DT>extends <A HREF="../../../net/spy/memcached/compat/SpyThread.html" title="class in net.spy.memcached.compat">SpyThread</A><DT>implements <A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></DL>
</PRE>

<P>
Client to a memcached server.

 <h2>Basic usage</h2>

 <pre>
        MemcachedClient c=new MemcachedClient(
                new InetSocketAddress("hostname", portNum));

        // Store a value (async) for one hour
        c.set("someKey", 3600, someObject);
        // Retrieve a value.
        Object myObject=c.get("someKey");
        </pre>

        <h2>Advanced Usage</h2>

        <p>
         MemcachedClient may be processing a great deal of asynchronous messages or
         possibly dealing with an unreachable memcached, which may delay processing.
         If a memcached is disabled, for example, MemcachedConnection will continue
         to attempt to reconnect and replay pending operations until it comes back
         up.  To prevent this from causing your application to hang, you can use
         one of the asynchronous mechanisms to time out a request and cancel the
         operation to the server.
        </p>

        <pre>
        // Get a memcached client connected to several servers
        MemcachedClient c=new MemcachedClient(
                AddrUtil.getAddresses("server1:11211 server2:11211"));

        // Try to get a value, for up to 5 seconds, and cancel if it doesn't return
        Object myObj=null;
        Future&lt;Object&gt; f=c.asyncGet("someKey");
        try {
                myObj=f.get(5, TimeUnit.SECONDS);
        } catch(TimeoutException e) {
                // Since we don't need this, go ahead and cancel the operation.  This
                // is not strictly necessary, but it'll save some work on the server.
                f.cancel();
                // Do other timeout related stuff
        }
 </pre>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_java.lang.Thread"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class java.lang.Thread</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>java.lang.Thread.State, java.lang.Thread.UncaughtExceptionHandler</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.lang.Thread"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class java.lang.Thread</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>MAX_PRIORITY, MIN_PRIORITY, NORM_PRIORITY</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.spy.memcached.MemcachedClientIF"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface net.spy.memcached.<A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#MAX_KEY_LENGTH">MAX_KEY_LENGTH</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#MemcachedClient(net.spy.memcached.ConnectionFactory, java.util.List)">MemcachedClient</A></B>(<A HREF="../../../net/spy/memcached/ConnectionFactory.html" title="interface in net.spy.memcached">ConnectionFactory</A>&nbsp;cf,
                java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a memcache client over the specified memcached locations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#MemcachedClient(java.net.InetSocketAddress...)">MemcachedClient</A></B>(java.net.InetSocketAddress...&nbsp;ia)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a memcache client operating on the specified memcached locations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#MemcachedClient(java.util.List)">MemcachedClient</A></B>(java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a memcache client over the specified memcached locations.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#add(java.lang.String, int, java.lang.Object)">add</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an object to the cache (using the default transcoder)
 iff it does not exist already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#add(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">add</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    T&nbsp;o,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add an object to the cache iff it does not exist already.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#addObserver(net.spy.memcached.ConnectionObserver)">addObserver</A></B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a connection observer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#append(long, java.lang.String, java.lang.Object)">append</A></B>(long&nbsp;cas,
       java.lang.String&nbsp;key,
       java.lang.Object&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#append(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">append</A></B>(long&nbsp;cas,
       java.lang.String&nbsp;key,
       T&nbsp;val,
       <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncCAS(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)">asyncCAS</A></B>(java.lang.String&nbsp;key,
         long&nbsp;casId,
         int&nbsp;exp,
         T&nbsp;value,
         <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncCAS(java.lang.String, long, java.lang.Object)">asyncCAS</A></B>(java.lang.String&nbsp;key,
         long&nbsp;casId,
         java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous CAS operation using the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncCAS(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)">asyncCAS</A></B>(java.lang.String&nbsp;key,
         long&nbsp;casId,
         T&nbsp;value,
         <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncDecr(java.lang.String, int)">asyncDecr</A></B>(java.lang.String&nbsp;key,
          int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronous decrement.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGet(java.lang.String)">asyncGet</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the given key asynchronously and decode with the default
 transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGet(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGet</A></B>(java.lang.String&nbsp;key,
         <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the given key asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Collection)">asyncGetBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache and decode them
 with the given transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">asyncGetBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
             <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asynchronously get a bunch of objects from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(java.lang.String...)">asyncGetBulk</A></B>(java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Varargs wrapper for asynchronous bulk gets with the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGetBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">asyncGetBulk</A></B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
             java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Varargs wrapper for asynchronous bulk gets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGets(java.lang.String)">asyncGets</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) the given key asynchronously and decode using
 the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncGets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGets</A></B>(java.lang.String&nbsp;key,
          <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) the given key asynchronously.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#asyncIncr(java.lang.String, int)">asyncIncr</A></B>(java.lang.String&nbsp;key,
          int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asychronous increment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A></CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#cas(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)">cas</A></B>(java.lang.String&nbsp;key,
    long&nbsp;casId,
    int&nbsp;exp,
    T&nbsp;value,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a synchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#cas(java.lang.String, long, java.lang.Object)">cas</A></B>(java.lang.String&nbsp;key,
    long&nbsp;casId,
    java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a synchronous CAS operation with the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A></CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#cas(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)">cas</A></B>(java.lang.String&nbsp;key,
    long&nbsp;casId,
    T&nbsp;value,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a synchronous CAS operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, int)">decr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given key by the given value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, int, long)">decr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#decr(java.lang.String, int, long, int)">decr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def,
     int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrement the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#delete(java.lang.String)">delete</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete the given key from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#delete(java.lang.String, int)">delete</A></B>(java.lang.String&nbsp;key,
       int&nbsp;hold)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Hold values are no longer honored.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#flush()">flush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flush all caches from all servers immediately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#flush(int)">flush</A></B>(int&nbsp;delay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flush all caches from all servers with a delay of application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#get(java.lang.String)">get</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get with a single key and decode using the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#get(java.lang.String, net.spy.memcached.transcoders.Transcoder)">get</A></B>(java.lang.String&nbsp;key,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get with a single key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Collection&lt;java.net.SocketAddress&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getAvailableServers()">getAvailableServers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the addresses of available servers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.util.Collection)">getBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.Map&lt;java.lang.String,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">getBulk</A></B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
        <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(java.lang.String...)">getBulk</A></B>(java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.Map&lt;java.lang.String,T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">getBulk</A></B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
        java.lang.String...&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the values for multiple keys from the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/NodeLocator.html" title="interface in net.spy.memcached">NodeLocator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getNodeLocator()">getNodeLocator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a read-only wrapper around the node locator wrapping this instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#gets(java.lang.String)">gets</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) with a single key using the default transcoder.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#gets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">gets</A></B>(java.lang.String&nbsp;key,
     <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets (with CAS support) with a single key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getStats()">getStats</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all of the stats from all of the connections.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getStats(java.lang.String)">getStats</A></B>(java.lang.String&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a set of stats from all connections.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;java.lang.Object&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getTranscoder()">getTranscoder</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the default transcoder that's in use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Collection&lt;java.net.SocketAddress&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getUnavailableServers()">getUnavailableServers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the addresses of unavailable servers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.net.SocketAddress,java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#getVersions()">getVersions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the versions of all of the connected memcacheds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, int)">incr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given key by the given amount.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, int, long)">incr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#incr(java.lang.String, int, long, int)">incr</A></B>(java.lang.String&nbsp;key,
     int&nbsp;by,
     long&nbsp;def,
     int&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increment the given counter, returning the new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#prepend(long, java.lang.String, java.lang.Object)">prepend</A></B>(long&nbsp;cas,
        java.lang.String&nbsp;key,
        java.lang.Object&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prepend to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#prepend(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">prepend</A></B>(long&nbsp;cas,
        java.lang.String&nbsp;key,
        T&nbsp;val,
        <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prepend to an existing value in the cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#removeObserver(net.spy.memcached.ConnectionObserver)">removeObserver</A></B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove a connection observer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#replace(java.lang.String, int, java.lang.Object)">replace</A></B>(java.lang.String&nbsp;key,
        int&nbsp;exp,
        java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace an object with the given value (transcoded with the default
 transcoder) iff there is already a value for the given key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#replace(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">replace</A></B>(java.lang.String&nbsp;key,
        int&nbsp;exp,
        T&nbsp;o,
        <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace an object with the given value iff there is already a value
 for the given key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#run()">run</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Infinitely loop processing IO.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#set(java.lang.String, int, java.lang.Object)">set</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set an object in the cache (using the default transcoder)
 regardless of any existing value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#set(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">set</A></B>(java.lang.String&nbsp;key,
    int&nbsp;exp,
    T&nbsp;o,
    <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set an object in the cache regardless of any existing value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shut down immediately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#shutdown(long, java.util.concurrent.TimeUnit)">shutdown</A></B>(long&nbsp;timeout,
         java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shut down this client gracefully.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../net/spy/memcached/MemcachedClient.html#waitForQueues(long, java.util.concurrent.TimeUnit)">waitForQueues</A></B>(long&nbsp;timeout,
              java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for the queues to die down.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.spy.memcached.compat.SpyThread"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class net.spy.memcached.compat.<A HREF="../../../net/spy/memcached/compat/SpyThread.html" title="class in net.spy.memcached.compat">SpyThread</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../net/spy/memcached/compat/SpyThread.html#getLogger()">getLogger</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Thread"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Thread</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>activeCount, checkAccess, countStackFrames, currentThread, destroy, dumpStack, enumerate, getAllStackTraces, getContextClassLoader, getDefaultUncaughtExceptionHandler, getId, getName, getPriority, getStackTrace, getState, getThreadGroup, getUncaughtExceptionHandler, holdsLock, interrupt, interrupted, isAlive, isDaemon, isInterrupted, join, join, join, resume, setContextClassLoader, setDaemon, setDefaultUncaughtExceptionHandler, setName, setPriority, setUncaughtExceptionHandler, sleep, sleep, start, stop, stop, suspend, toString, yield</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MemcachedClient(java.net.InetSocketAddress...)"><!-- --></A><H3>
MemcachedClient</H3>
<PRE>
public <B>MemcachedClient</B>(java.net.InetSocketAddress...&nbsp;ia)
                throws java.io.IOException</PRE>
<DL>
<DD>Get a memcache client operating on the specified memcached locations.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>ia</CODE> - the memcached locations
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if connections cannot be established</DL>
</DL>
<HR>

<A NAME="MemcachedClient(java.util.List)"><!-- --></A><H3>
MemcachedClient</H3>
<PRE>
public <B>MemcachedClient</B>(java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)
                throws java.io.IOException</PRE>
<DL>
<DD>Get a memcache client over the specified memcached locations.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>addrs</CODE> - the socket addrs
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if connections cannot be established</DL>
</DL>
<HR>

<A NAME="MemcachedClient(net.spy.memcached.ConnectionFactory, java.util.List)"><!-- --></A><H3>
MemcachedClient</H3>
<PRE>
public <B>MemcachedClient</B>(<A HREF="../../../net/spy/memcached/ConnectionFactory.html" title="interface in net.spy.memcached">ConnectionFactory</A>&nbsp;cf,
                       java.util.List&lt;java.net.InetSocketAddress&gt;&nbsp;addrs)
                throws java.io.IOException</PRE>
<DL>
<DD>Get a memcache client over the specified memcached locations.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>bufSize</CODE> - read buffer size per connection (in bytes)<DD><CODE>addrs</CODE> - the socket addresses
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if connections cannot be established</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getAvailableServers()"><!-- --></A><H3>
getAvailableServers</H3>
<PRE>
public java.util.Collection&lt;java.net.SocketAddress&gt; <B>getAvailableServers</B>()</PRE>
<DL>
<DD>Get the addresses of available servers.

 <p>
 This is based on a snapshot in time so shouldn't be considered
 completely accurate, but is a useful for getting a feel for what's
 working and what's not working.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getAvailableServers()">getAvailableServers</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUnavailableServers()"><!-- --></A><H3>
getUnavailableServers</H3>
<PRE>
public java.util.Collection&lt;java.net.SocketAddress&gt; <B>getUnavailableServers</B>()</PRE>
<DL>
<DD>Get the addresses of unavailable servers.

 <p>
 This is based on a snapshot in time so shouldn't be considered
 completely accurate, but is a useful for getting a feel for what's
 working and what's not working.
 </p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getUnavailableServers()">getUnavailableServers</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNodeLocator()"><!-- --></A><H3>
getNodeLocator</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/NodeLocator.html" title="interface in net.spy.memcached">NodeLocator</A> <B>getNodeLocator</B>()</PRE>
<DL>
<DD>Get a read-only wrapper around the node locator wrapping this instance.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getNodeLocator()">getNodeLocator</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTranscoder()"><!-- --></A><H3>
getTranscoder</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;java.lang.Object&gt; <B>getTranscoder</B>()</PRE>
<DL>
<DD>Get the default transcoder that's in use.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getTranscoder()">getTranscoder</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="append(long, java.lang.String, java.lang.Object)"><!-- --></A><H3>
append</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>append</B>(long&nbsp;cas,
                                                             java.lang.String&nbsp;key,
                                                             java.lang.Object&nbsp;val)</PRE>
<DL>
<DD>Append to an existing value in the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#append(long, java.lang.String, java.lang.Object)">append</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be appended<DD><CODE>val</CODE> - the value to append
<DT><B>Returns:</B><DD>a future indicating success
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="append(long,java.lang.String,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="append(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
append</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>append</B>(long&nbsp;cas,
                                                                 java.lang.String&nbsp;key,
                                                                 T&nbsp;val,
                                                                 <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Append to an existing value in the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#append(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">append</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be appended<DD><CODE>val</CODE> - the value to append<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future indicating success
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="prepend(long, java.lang.String, java.lang.Object)"><!-- --></A><H3>
prepend</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>prepend</B>(long&nbsp;cas,
                                                              java.lang.String&nbsp;key,
                                                              java.lang.Object&nbsp;val)</PRE>
<DL>
<DD>Prepend to an existing value in the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#prepend(long, java.lang.String, java.lang.Object)">prepend</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be prepended<DD><CODE>val</CODE> - the value to append
<DT><B>Returns:</B><DD>a future indicating success
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="prepend(long,java.lang.String,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="prepend(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
prepend</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>prepend</B>(long&nbsp;cas,
                                                                  java.lang.String&nbsp;key,
                                                                  T&nbsp;val,
                                                                  <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Prepend to an existing value in the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#prepend(long, java.lang.String, T, net.spy.memcached.transcoders.Transcoder)">prepend</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cas</CODE> - cas identifier (ignored in the ascii protocol)<DD><CODE>key</CODE> - the key to whose value will be prepended<DD><CODE>val</CODE> - the value to append<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future indicating success
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncCAS(java.lang.String,long,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="asyncCAS(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncCAS</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt; <B>asyncCAS</B>(java.lang.String&nbsp;key,
                                                             long&nbsp;casId,
                                                             T&nbsp;value,
                                                             <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Asynchronous CAS operation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncCAS(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)">asyncCAS</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future that will indicate the status of the CAS
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncCAS(java.lang.String,long,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="asyncCAS(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncCAS</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt; <B>asyncCAS</B>(java.lang.String&nbsp;key,
                                                             long&nbsp;casId,
                                                             int&nbsp;exp,
                                                             T&nbsp;value,
                                                             <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Asynchronous CAS operation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future that will indicate the status of the CAS
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncCAS(java.lang.String, long, java.lang.Object)"><!-- --></A><H3>
asyncCAS</H3>
<PRE>
public java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A>&gt; <B>asyncCAS</B>(java.lang.String&nbsp;key,
                                                         long&nbsp;casId,
                                                         java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Asynchronous CAS operation using the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncCAS(java.lang.String, long, java.lang.Object)">asyncCAS</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value
<DT><B>Returns:</B><DD>a future that will indicate the status of the CAS
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="cas(java.lang.String,long,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="cas(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
cas</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A> <B>cas</B>(java.lang.String&nbsp;key,
                           long&nbsp;casId,
                           T&nbsp;value,
                           <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Perform a synchronous CAS operation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#cas(java.lang.String, long, T, net.spy.memcached.transcoders.Transcoder)">cas</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a CASResponse
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if global operation timeout is
         exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="cas(java.lang.String,long,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="cas(java.lang.String, long, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
cas</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A> <B>cas</B>(java.lang.String&nbsp;key,
                           long&nbsp;casId,
                           int&nbsp;exp,
                           T&nbsp;value,
                           <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Perform a synchronous CAS operation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>value</CODE> - the new value<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a CASResponse
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if global operation timeout is
         exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="cas(java.lang.String, long, java.lang.Object)"><!-- --></A><H3>
cas</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/CASResponse.html" title="enum in net.spy.memcached">CASResponse</A> <B>cas</B>(java.lang.String&nbsp;key,
                       long&nbsp;casId,
                       java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Perform a synchronous CAS operation with the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#cas(java.lang.String, long, java.lang.Object)">cas</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>casId</CODE> - the CAS identifier (from a gets operation)<DD><CODE>value</CODE> - the new value
<DT><B>Returns:</B><DD>a CASResponse
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="add(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
add</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>add</B>(java.lang.String&nbsp;key,
                                                              int&nbsp;exp,
                                                              T&nbsp;o,
                                                              <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Add an object to the cache iff it does not exist already.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as
 given, and will be processed per the memcached protocol specification:
 </p>

 <blockquote>
 <p>
 The actual value sent may either be
 Unix time (number of seconds since January 1, 1970, as a 32-bit
 value), or a number of seconds starting from current time. In the
 latter case, this number of seconds may not exceed 60*60*24*30 (number
 of seconds in 30 days); if the number sent by a client is larger than
 that, the server will consider it to be real Unix time value rather
 than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#add(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">add</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String, int, java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>add</B>(java.lang.String&nbsp;key,
                                                          int&nbsp;exp,
                                                          java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Add an object to the cache (using the default transcoder)
 iff it does not exist already.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as
 given, and will be processed per the memcached protocol specification:
 </p>

 <blockquote>
 <p>
 The actual value sent may either be
 Unix time (number of seconds since January 1, 1970, as a 32-bit
 value), or a number of seconds starting from current time. In the
 latter case, this number of seconds may not exceed 60*60*24*30 (number
 of seconds in 30 days); if the number sent by a client is larger than
 that, the server will consider it to be real Unix time value rather
 than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#add(java.lang.String, int, java.lang.Object)">add</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="set(java.lang.String,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="set(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
set</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>set</B>(java.lang.String&nbsp;key,
                                                              int&nbsp;exp,
                                                              T&nbsp;o,
                                                              <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Set an object in the cache regardless of any existing value.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as
 given, and will be processed per the memcached protocol specification:
 </p>

 <blockquote>
 <p>
 The actual value sent may either be
 Unix time (number of seconds since January 1, 1970, as a 32-bit
 value), or a number of seconds starting from current time. In the
 latter case, this number of seconds may not exceed 60*60*24*30 (number
 of seconds in 30 days); if the number sent by a client is larger than
 that, the server will consider it to be real Unix time value rather
 than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#set(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">set</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="set(java.lang.String, int, java.lang.Object)"><!-- --></A><H3>
set</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>set</B>(java.lang.String&nbsp;key,
                                                          int&nbsp;exp,
                                                          java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Set an object in the cache (using the default transcoder)
 regardless of any existing value.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as
 given, and will be processed per the memcached protocol specification:
 </p>

 <blockquote>
 <p>
 The actual value sent may either be
 Unix time (number of seconds since January 1, 1970, as a 32-bit
 value), or a number of seconds starting from current time. In the
 latter case, this number of seconds may not exceed 60*60*24*30 (number
 of seconds in 30 days); if the number sent by a client is larger than
 that, the server will consider it to be real Unix time value rather
 than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#set(java.lang.String, int, java.lang.Object)">set</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="replace(java.lang.String,int,java.lang.Object,net.spy.memcached.transcoders.Transcoder)"><!-- --></A><A NAME="replace(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
replace</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>replace</B>(java.lang.String&nbsp;key,
                                                                  int&nbsp;exp,
                                                                  T&nbsp;o,
                                                                  <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Replace an object with the given value iff there is already a value
 for the given key.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as
 given, and will be processed per the memcached protocol specification:
 </p>

 <blockquote>
 <p>
 The actual value sent may either be
 Unix time (number of seconds since January 1, 1970, as a 32-bit
 value), or a number of seconds starting from current time. In the
 latter case, this number of seconds may not exceed 60*60*24*30 (number
 of seconds in 30 days); if the number sent by a client is larger than
 that, the server will consider it to be real Unix time value rather
 than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#replace(java.lang.String, int, T, net.spy.memcached.transcoders.Transcoder)">replace</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize the value
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="replace(java.lang.String, int, java.lang.Object)"><!-- --></A><H3>
replace</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>replace</B>(java.lang.String&nbsp;key,
                                                              int&nbsp;exp,
                                                              java.lang.Object&nbsp;o)</PRE>
<DL>
<DD>Replace an object with the given value (transcoded with the default
 transcoder) iff there is already a value for the given key.

 <p>
 The <code>exp</code> value is passed along to memcached exactly as
 given, and will be processed per the memcached protocol specification:
 </p>

 <blockquote>
 <p>
 The actual value sent may either be
 Unix time (number of seconds since January 1, 1970, as a 32-bit
 value), or a number of seconds starting from current time. In the
 latter case, this number of seconds may not exceed 60*60*24*30 (number
 of seconds in 30 days); if the number sent by a client is larger than
 that, the server will consider it to be real Unix time value rather
 than an offset from current time.
 </p>
 </blockquote>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#replace(java.lang.String, int, java.lang.Object)">replace</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key under which this object should be added.<DD><CODE>exp</CODE> - the expiration of this object<DD><CODE>o</CODE> - the object to store
<DT><B>Returns:</B><DD>a future representing the processing of this operation
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGet(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGet</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;T&gt; <B>asyncGet</B>(java.lang.String&nbsp;key,
                                                   <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get the given key asynchronously.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGet(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGet</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGet(java.lang.String)"><!-- --></A><H3>
asyncGet</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Object&gt; <B>asyncGet</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Get the given key asynchronously and decode with the default
 transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGet(java.lang.String)">asyncGet</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGets(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGets</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt;&gt; <B>asyncGets</B>(java.lang.String&nbsp;key,
                                                              <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Gets (with CAS support) the given key asynchronously.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">asyncGets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGets(java.lang.String)"><!-- --></A><H3>
asyncGets</H3>
<PRE>
public java.util.concurrent.Future&lt;<A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt;&gt; <B>asyncGets</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Gets (with CAS support) the given key asynchronously and decode using
 the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGets(java.lang.String)">asyncGets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to fetch
<DT><B>Returns:</B><DD>a future that will hold the return value of the fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="gets(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
gets</H3>
<PRE>
public &lt;T&gt; <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;T&gt; <B>gets</B>(java.lang.String&nbsp;key,
                            <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Gets (with CAS support) with a single key.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#gets(java.lang.String, net.spy.memcached.transcoders.Transcoder)">gets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>the result from the cache and CAS id (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="gets(java.lang.String)"><!-- --></A><H3>
gets</H3>
<PRE>
public <A HREF="../../../net/spy/memcached/CASValue.html" title="class in net.spy.memcached">CASValue</A>&lt;java.lang.Object&gt; <B>gets</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Gets (with CAS support) with a single key using the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#gets(java.lang.String)">gets</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get
<DT><B>Returns:</B><DD>the result from the cache and CAS id (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
get</H3>
<PRE>
public &lt;T&gt; T <B>get</B>(java.lang.String&nbsp;key,
                 <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get with a single key.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#get(java.lang.String, net.spy.memcached.transcoders.Transcoder)">get</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>the result from the cache (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String)"><!-- --></A><H3>
get</H3>
<PRE>
public java.lang.Object <B>get</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Get with a single key and decode using the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#get(java.lang.String)">get</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to get
<DT><B>Returns:</B><DD>the result from the cache (null if there is none)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,T&gt;&gt; <B>asyncGetBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
                                                                                       <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys to request<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.util.Collection)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt; <B>asyncGetBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</PRE>
<DL>
<DD>Asynchronously get a bunch of objects from the cache and decode them
 with the given transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.util.Collection)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys to request
<DT><B>Returns:</B><DD>a Future result of that fetch
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public &lt;T&gt; java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,T&gt;&gt; <B>asyncGetBulk</B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
                                                                                       java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Varargs wrapper for asynchronous bulk gets.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value<DD><CODE>keys</CODE> - one more more keys to get
<DT><B>Returns:</B><DD>the future values of those keys
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncGetBulk(java.lang.String...)"><!-- --></A><H3>
asyncGetBulk</H3>
<PRE>
public java.util.concurrent.Future&lt;java.util.Map&lt;java.lang.String,java.lang.Object&gt;&gt; <B>asyncGetBulk</B>(java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Varargs wrapper for asynchronous bulk gets with the default transcoder.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncGetBulk(java.lang.String...)">asyncGetBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - one more more keys to get
<DT><B>Returns:</B><DD>the future values of those keys
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public &lt;T&gt; java.util.Map&lt;java.lang.String,T&gt; <B>getBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys,
                                                     <A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.util.Collection, net.spy.memcached.transcoders.Transcoder)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys<DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.util.Collection)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.Object&gt; <B>getBulk</B>(java.util.Collection&lt;java.lang.String&gt;&nbsp;keys)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.util.Collection)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public &lt;T&gt; java.util.Map&lt;java.lang.String,T&gt; <B>getBulk</B>(<A HREF="../../../net/spy/memcached/transcoders/Transcoder.html" title="interface in net.spy.memcached.transcoders">Transcoder</A>&lt;T&gt;&nbsp;tc,
                                                     java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(net.spy.memcached.transcoders.Transcoder, java.lang.String...)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tc</CODE> - the transcoder to serialize and unserialize value<DD><CODE>keys</CODE> - the keys
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getBulk(java.lang.String...)"><!-- --></A><H3>
getBulk</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.Object&gt; <B>getBulk</B>(java.lang.String...&nbsp;keys)</PRE>
<DL>
<DD>Get the values for multiple keys from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getBulk(java.lang.String...)">getBulk</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keys</CODE> - the keys
<DT><B>Returns:</B><DD>a map of the values (for each value that exists)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getVersions()"><!-- --></A><H3>
getVersions</H3>
<PRE>
public java.util.Map&lt;java.net.SocketAddress,java.lang.String&gt; <B>getVersions</B>()</PRE>
<DL>
<DD>Get the versions of all of the connected memcacheds.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getVersions()">getVersions</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getStats()"><!-- --></A><H3>
getStats</H3>
<PRE>
public java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt; <B>getStats</B>()</PRE>
<DL>
<DD>Get all of the stats from all of the connections.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getStats()">getStats</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="getStats(java.lang.String)"><!-- --></A><H3>
getStats</H3>
<PRE>
public java.util.Map&lt;java.net.SocketAddress,java.util.Map&lt;java.lang.String,java.lang.String&gt;&gt; <B>getStats</B>(java.lang.String&nbsp;arg)</PRE>
<DL>
<DD>Get a set of stats from all connections.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#getStats(java.lang.String)">getStats</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arg</CODE> - which stats to get
<DT><B>Returns:</B><DD>a Map of the server SocketAddress to a map of String stat
                   keys to String stat values.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, int)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by)</PRE>
<DL>
<DD>Increment the given key by the given amount.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, int)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment
<DT><B>Returns:</B><DD>the new value (-1 if the key doesn't exist)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, int)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by)</PRE>
<DL>
<DD>Decrement the given key by the given value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, int)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the value
<DT><B>Returns:</B><DD>the new value (-1 if the key doesn't exist)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, int, long, int)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def,
                 int&nbsp;exp)</PRE>
<DL>
<DD>Increment the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, int, long, int)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment<DD><CODE>def</CODE> - the default value (if the counter does not exist)<DD><CODE>exp</CODE> - the expiration of this object
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to increment or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, int, long, int)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def,
                 int&nbsp;exp)</PRE>
<DL>
<DD>Decrement the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, int, long, int)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to decrement<DD><CODE>def</CODE> - the default value (if the counter does not exist)<DD><CODE>exp</CODE> - the expiration of this object
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to decrement or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncIncr(java.lang.String, int)"><!-- --></A><H3>
asyncIncr</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Long&gt; <B>asyncIncr</B>(java.lang.String&nbsp;key,
                                                             int&nbsp;by)</PRE>
<DL>
<DD>Asychronous increment.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncIncr(java.lang.String, int)">asyncIncr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a future with the incremented value, or -1 if the
                   increment failed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="asyncDecr(java.lang.String, int)"><!-- --></A><H3>
asyncDecr</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Long&gt; <B>asyncDecr</B>(java.lang.String&nbsp;key,
                                                             int&nbsp;by)</PRE>
<DL>
<DD>Asynchronous decrement.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#asyncDecr(java.lang.String, int)">asyncDecr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a future with the decremented value, or -1 if the
                   increment failed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="incr(java.lang.String, int, long)"><!-- --></A><H3>
incr</H3>
<PRE>
public long <B>incr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def)</PRE>
<DL>
<DD>Increment the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#incr(java.lang.String, int, long)">incr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to increment<DD><CODE>def</CODE> - the default value (if the counter does not exist)
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to increment or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="decr(java.lang.String, int, long)"><!-- --></A><H3>
decr</H3>
<PRE>
public long <B>decr</B>(java.lang.String&nbsp;key,
                 int&nbsp;by,
                 long&nbsp;def)</PRE>
<DL>
<DD>Decrement the given counter, returning the new value.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#decr(java.lang.String, int, long)">decr</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>by</CODE> - the amount to decrement<DD><CODE>def</CODE> - the default value (if the counter does not exist)
<DT><B>Returns:</B><DD>the new value, or -1 if we were unable to decrement or add
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../net/spy/memcached/OperationTimeoutException.html" title="class in net.spy.memcached">OperationTimeoutException</A></CODE> - if the global operation timeout is
                   exceeded
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="delete(java.lang.String, int)"><!-- --></A><H3>
delete</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>delete</B>(java.lang.String&nbsp;key,
                                                                        int&nbsp;hold)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Hold values are no longer honored.</I>
<P>
<DD>Delete the given key from the cache.

 <p>
 The hold argument specifies the amount of time in seconds (or Unix time
 until which) the client wishes the server to refuse "add" and "replace"
 commands with this key. For this amount of item, the item is put into a
 delete queue, which means that it won't possible to retrieve it by the
 "get" command, but "add" and "replace" command with this key will also
 fail (the "set" command will succeed, however). After the time passes,
 the item is finally deleted from server memory.
 </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to delete<DD><CODE>hold</CODE> - how long the key should be unavailable to add commands</DL>
</DD>
</DL>
<HR>

<A NAME="delete(java.lang.String)"><!-- --></A><H3>
delete</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>delete</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Delete the given key from the cache.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#delete(java.lang.String)">delete</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key to delete
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="flush(int)"><!-- --></A><H3>
flush</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>flush</B>(int&nbsp;delay)</PRE>
<DL>
<DD>Flush all caches from all servers with a delay of application.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#flush(int)">flush</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A><H3>
flush</H3>
<PRE>
public java.util.concurrent.Future&lt;java.lang.Boolean&gt; <B>flush</B>()</PRE>
<DL>
<DD>Flush all caches from all servers immediately.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#flush()">flush</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="run()"><!-- --></A><H3>
run</H3>
<PRE>
public void <B>run</B>()</PRE>
<DL>
<DD>Infinitely loop processing IO.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>run</CODE> in interface <CODE>java.lang.Runnable</CODE><DT><B>Overrides:</B><DD><CODE>run</CODE> in class <CODE>java.lang.Thread</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL>
<DD>Shut down immediately.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#shutdown()">shutdown</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
shutdown</H3>
<PRE>
public boolean <B>shutdown</B>(long&nbsp;timeout,
                        java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Shut down this client gracefully.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#shutdown(long, java.util.concurrent.TimeUnit)">shutdown</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="waitForQueues(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
waitForQueues</H3>
<PRE>
public boolean <B>waitForQueues</B>(long&nbsp;timeout,
                             java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Wait for the queues to die down.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#waitForQueues(long, java.util.concurrent.TimeUnit)">waitForQueues</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - in the rare circumstance where queue
         is too full to accept any more requests</DL>
</DD>
</DL>
<HR>

<A NAME="addObserver(net.spy.memcached.ConnectionObserver)"><!-- --></A><H3>
addObserver</H3>
<PRE>
public boolean <B>addObserver</B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</PRE>
<DL>
<DD>Add a connection observer.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#addObserver(net.spy.memcached.ConnectionObserver)">addObserver</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the observer was added.</DL>
</DD>
</DL>
<HR>

<A NAME="removeObserver(net.spy.memcached.ConnectionObserver)"><!-- --></A><H3>
removeObserver</H3>
<PRE>
public boolean <B>removeObserver</B>(<A HREF="../../../net/spy/memcached/ConnectionObserver.html" title="interface in net.spy.memcached">ConnectionObserver</A>&nbsp;obs)</PRE>
<DL>
<DD>Remove a connection observer.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html#removeObserver(net.spy.memcached.ConnectionObserver)">removeObserver</A></CODE> in interface <CODE><A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached">MemcachedClientIF</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the observer existed, but no longer does</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../net/spy/memcached/KeyUtil.html" title="class in net.spy.memcached"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../net/spy/memcached/MemcachedClientIF.html" title="interface in net.spy.memcached"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?net/spy/memcached/MemcachedClient.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MemcachedClient.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_java.lang.Thread">NESTED</A>&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.lang.Thread">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
